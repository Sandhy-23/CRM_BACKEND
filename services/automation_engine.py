import json
from flask import g
from extensions import db
from models.automation import AutomationRule, AutomationLog
from models.task import Task
from datetime import datetime, timedelta

def check_condition(record, condition):
    """Evaluates a single condition against the record."""
    field = condition.field_name
    operator = condition.operator
    target_value = condition.value
    
    # Get actual value from record
    record_value = getattr(record, field, None)
    
    # Convert to string for comparison to be safe
    record_val_str = str(record_value).lower() if record_value is not None else ""
    target_val_str = str(target_value).lower()
    
    if operator == "equals":
        return record_val_str == target_val_str
    elif operator == "contains":
        return target_val_str in record_val_str
    elif operator == "not_equals":
        return record_val_str != target_val_str
    elif operator == "starts_with":
        return record_val_str.startswith(target_val_str)
    
    return False

def evaluate_conditions(record, conditions):
    """Evaluates all conditions for a rule."""
    if not conditions:
        return True
        
    # Simple AND logic for now (all must match)
    # If you need logical_join support (OR), implement accumulation here
    for cond in conditions:
        if not check_condition(record, cond):
            return False
    return True

def execute_action(record, action, user_id):
    """Executes a single action."""
    config = json.loads(action.config_json)
    
    if action.action_type == "assign_owner":
        new_owner_id = config.get("user_id")
        if new_owner_id:
            if hasattr(record, "owner_id"):
                record.owner_id = new_owner_id
            if hasattr(record, "assigned_to"):
                record.assigned_to = new_owner_id
            db.session.add(record)
            return f"Assigned owner to User ID {new_owner_id}"
            
    elif action.action_type == "create_task":
        days_due = config.get("days_due", 1)
        due_date = datetime.utcnow().date() + timedelta(days=days_due)
        
        # Determine company_id from record
        company_id = getattr(record, 'company_id', getattr(record, 'organization_id', None))
        
        new_task = Task(
            title=config.get("title", "Automated Task"),
            description=f"Auto-generated by automation rule.",
            status="Pending",
            priority="Medium",
            assigned_to=getattr(record, 'owner_id', user_id),
            created_by=user_id, # System or trigger user
            company_id=company_id,
            due_date=due_date
        )
        
        # Link to record
        if hasattr(record, 'id'):
            # Infer module from record type or pass it in. 
            # For now, check attributes
            if hasattr(record, 'first_name') and hasattr(record, 'last_name'): # Lead
                new_task.lead_id = record.id
            elif hasattr(record, 'amount') and hasattr(record, 'stage'): # Deal
                new_task.deal_id = record.id
                
        db.session.add(new_task)
        return f"Created Task: {new_task.title}"
        
    return "Unknown action type"

def run_automation(module, trigger_event, record):
    """Main entry point to trigger automation rules."""
    # Ensure we have a company context
    company_id = getattr(g, 'company_id', None)
    user_id = getattr(g, 'user_id', None)
    
    if not company_id:
        # Fallback: try to get from record
        company_id = getattr(record, 'company_id', getattr(record, 'organization_id', None))
        
    if not company_id:
        print("‚ö†Ô∏è Automation Skipped: No company_id found context.")
        return

    print(f"‚öôÔ∏è Automation Engine: Checking rules for {module} ({trigger_event}) in Org {company_id}...")
    
    rules = AutomationRule.query.filter_by(
        module=module,
        trigger_event=trigger_event,
        is_active=True,
        company_id=company_id
    ).order_by(AutomationRule.priority.asc()).all()
    
    for rule in rules:
        if evaluate_conditions(record, rule.conditions):
            print(f"   ‚úÖ Rule Matched: {rule.name}")
            
            for action in rule.actions:
                try:
                    msg = execute_action(record, action, user_id)
                    db.session.add(AutomationLog(rule_id=rule.id, module=module, record_id=record.id, status="success", message=msg))
                except Exception as e:
                    print(f"‚ùå Action Failed: {e}")
                    db.session.add(AutomationLog(rule_id=rule.id, module=module, record_id=record.id, status="failed", message=str(e)))
            
            db.session.commit()
            
            if rule.stop_on_match:
                print("   üõë Stop on match active. Halting further rules.")
                break